import { createHotContext as __vite__createHotContext } from "/vendor/vite-client.js";import.meta.hot = __vite__createHotContext("/src/components/Content.svelte.js");/* src/components/Content.svelte generated by Svelte v3.52.0 */
import {
	SvelteComponentDev,
	add_location,
	attr_dev,
	check_outros,
	create_component,
	destroy_component,
	detach_dev,
	dispatch_dev,
	element,
	empty,
	globals,
	group_outros,
	init,
	insert_dev,
	listen_dev,
	mount_component,
	safe_not_equal,
	set_input_value,
	transition_in,
	transition_out,
	validate_slots
} from "/vendor/.vite-deps-svelte_internal.js__v--31590584.js";

const { console: console_1 } = globals;
import Linote from "/src/components/Linote.svelte.js";
import hotkeys from '/vendor/.vite-deps-hotkeys-js.js__v--31590584.js';
const file = "src/components/Content.svelte";

// (50:0) {#if linote}
function create_if_block(ctx) {
	let linote_1;
	let current;

	linote_1 = new Linote({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(linote_1.$$.fragment);
		},
		m: function mount(target, anchor) {
			mount_component(linote_1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const linote_1_changes = {};

			if (dirty & /*$$scope, notes*/ 33) {
				linote_1_changes.$$scope = { dirty, ctx };
			}

			linote_1.$set(linote_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(linote_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(linote_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(linote_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(50:0) {#if linote}",
		ctx
	});

	return block;
}

// (52:2) <Linote>
function create_default_slot(ctx) {
	let textarea;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			textarea = element("textarea");
			attr_dev(textarea, "class", "s-gEYCCSF8-4E1");
			add_location(textarea, file, 51, 10, 1027);
		},
		m: function mount(target, anchor) {
			insert_dev(target, textarea, anchor);
			set_input_value(textarea, /*notes*/ ctx[0]);

			if (!mounted) {
				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*notes*/ 1) {
				set_input_value(textarea, /*notes*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(textarea);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(52:2) <Linote>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*linote*/ ctx[1] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*linote*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*linote*/ 2) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Content', slots, []);
	console.log("money");
	let notes = [];
	let linote = false;

	// let notes = [];
	function toggleLinote() {
		$$invalidate(1, linote = !linote);
	} // const element = document.activeElement;
	// const isInTextField = element.tagName === "INPUT" || element.tagName === "TEXTAREA";

	// if(isInTextField){
	// linote = !linote
	// }
	const getSelectedText = () => {
		const element = document.activeElement;
		const isInTextField = element.tagName === "INPUT" || element.tagName === "TEXTAREA";

		return isInTextField
		? element.value.substring(element.selectionStart, element.selectionEnd)
		: window.getSelection()?.toString() ?? "";
	};

	hotkeys('s', function () {
		const selectedText = getSelectedText();
		$$invalidate(0, notes = [...notes, selectedText]);
	});

	hotkeys('ctrl+l', function () {
		console.log("toggling linote");
		toggleLinote();
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Content> was created with unknown prop '${key}'`);
	});

	function textarea_input_handler() {
		notes = this.value;
		$$invalidate(0, notes);
	}

	$$self.$capture_state = () => ({
		Linote,
		hotkeys,
		notes,
		linote,
		toggleLinote,
		getSelectedText
	});

	$$self.$inject_state = $$props => {
		if ('notes' in $$props) $$invalidate(0, notes = $$props.notes);
		if ('linote' in $$props) $$invalidate(1, linote = $$props.linote);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [notes, linote, textarea_input_handler];
}

class Content extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Content",
			options,
			id: create_fragment.name
		});
	}
}

import * as ___SVELTE_HMR_HOT_API from '/vendor/svelte-hmr-runtime-hot-api-esm.js__v--31590584.js';import { adapter as ___SVELTE_HMR_HOT_API_PROXY_ADAPTER } from '/vendor/svelte-hmr-runtime-proxy-adapter-dom.js__v--31590584.js';if (import.meta && import.meta.hot) { if (false) import.meta.hot.acceptExports(['default']);; Content = ___SVELTE_HMR_HOT_API.applyHmr({ m: import.meta, id: "/Users/money/Projects/WebExtensions/SveltePlay/src/components/Content.svelte", hotOptions: {"preserveLocalState":false,"noPreserveStateKey":["@hmr:reset","@!hmr"],"preserveAllLocalStateKey":"@hmr:keep-all","preserveLocalStateKey":"@hmr:keep","noReload":false,"optimistic":false,"acceptNamedExports":true,"acceptAccessors":true,"injectCss":false,"cssEjectDelay":100,"native":false,"importAdapterName":"___SVELTE_HMR_HOT_API_PROXY_ADAPTER","noOverlay":true,"allowLiveBinding":false,"partialAccept":true}, Component: Content, ProxyAdapter: ___SVELTE_HMR_HOT_API_PROXY_ADAPTER, acceptable: true, preserveLocalState: false, emitCss: true, }); }
export default Content;


import "/src/components/Content.svelte__svelte_type--style_lang.css.js";
